// my point class
class Point2
{
	constructor(x = 0, y = 0)
	{
		this.x = x;
		this.y = y;
	}
}


// initialization
var ctrlPoints = new Array(0);
var cpRadius = 7;
var moveIdx = -1;
var mouseStartPoiint;

$(document).ready(initDocuemnt);

function initDocuemnt()
{
	// event handler
	$('#bezierDiv').on('mousedown', onMouseDown);
	$('#bezierDiv').on('mousemove', onMouseMove);
	$('#bezierDiv').on('mouseup', onMouseUp);
	// $('#bezierDiv').on('dbclick', onDbClick);
	$('#new-curve').on('click', onClickAddCurve);

	// initialize Canvas
	cvs = $('#bezierArea');
	cvsW = cvs.width();
	cvsH = $(window).height() - 80;
	cvs.height(cvsH);

	// init control points and svg objects
	createSvgObjects();
	updateBezierSvg(0, 0, false);
}

function onMouseDown(e)
{
	mouseStartPoiint = { x: e.offsetX, y: e.offsetY };

	let clickPoint = {
		x: e.offsetX - $('#bezierDiv').position().left,
		y: e.offsetY - $('#bezierDiv').position().top
	};

	for (let n=0; n<ctrlPoints.length; ++n)
	{
		let dis = Math.sqrt((ctrlPoints[n].x - clickPoint.x)**2 + (ctrlPoints[n].y - clickPoint.y)**2);
		if (dis <= cpRadius * 2) {
			moveIdx = n;
			break;
		}
	}
}

function onMouseMove(e)
{
	if (moveIdx >= 0)
	{
		let xDiff = e.offsetX - mouseStartPoiint.x;
		let yDiff = e.offsetY - mouseStartPoiint.y;
		updateBezierSvg(xDiff, yDiff, false);
	}
}

function onMouseUp(e)
{
	// update result point
	if (moveIdx >= 0)
	{
		let xDiff = e.offsetX - mouseStartPoiint.x;
		let yDiff = e.offsetY - mouseStartPoiint.y;

		if ((xDiff == 0) && (yDiff == 0))
		{
			// no move, just switch control mode
			let idStr = `#ctrl-point-${moveIdx}`;
			if ($(idStr).hasClass('cp-end'))
			{
				$(idStr).toggleClass('smooth');
				if ($(idStr).hasClass('smooth') && (moveIdx < ctrlPoints.length-1) && (moveIdx > 0))
				{
					// switch control mode from sharp to smooth --> set middle control point
					let xDir = ctrlPoints[moveIdx + 1].x - ctrlPoints[moveIdx].x;
					let yDir = ctrlPoints[moveIdx + 1].y - ctrlPoints[moveIdx].y;
					let orglen = Math.sqrt(xDir*xDir + yDir*yDir);
					xDir = ctrlPoints[moveIdx].x - ctrlPoints[moveIdx - 1].x;
					yDir = ctrlPoints[moveIdx].y - ctrlPoints[moveIdx - 1].y;
					let len = Math.sqrt(xDir*xDir + yDir*yDir);
					ctrlPoints[moveIdx + 1].x = ctrlPoints[moveIdx].x + orglen * xDir / len;
					ctrlPoints[moveIdx + 1].y = ctrlPoints[moveIdx].y + orglen * yDir / len;
				}
			}
		}else{
			// move control point
			ctrlPoints[moveIdx].x += xDiff;
			ctrlPoints[moveIdx].y += yDiff;
		}

		moveIdx = -1;
		updateBezierSvg(0, 0, true);
	}
}

// add new curve
function onClickAddCurve()
{
	createSvgObjects();
	updateBezierSvg(0, 0, false);
}

function updateBezierSvg(xDiff, yDiff, isUpdateBack)
{
	// 不能直接 tempCtPts[n] = ctrlPoints[n], 會變成 reference, 改一個動到兩個
	let tempCtPts = [];
	for (let n=0; n<ctrlPoints.length; ++n) tempCtPts[n] = {x:ctrlPoints[n].x, y: ctrlPoints[n].y};

	if (moveIdx >= 0)
	{
		// 目前正在移動控制點
		tempCtPts[moveIdx].x += xDiff;
		tempCtPts[moveIdx].y += yDiff;

		let isNeedUpdatePrevPoint = (moveIdx > 1) && $(`#ctrl-point-${moveIdx - 1}`).hasClass('smooth');
		let isNeedUpdateNextPoint = (moveIdx < tempCtPts.length-2) && $(`#ctrl-point-${moveIdx + 1}`).hasClass('smooth');

		// check is smooth mode
		if (isNeedUpdatePrevPoint)
		{
			// prev. point is smooth, update prev^2 point
			let xDir = tempCtPts[moveIdx - 2].x - tempCtPts[moveIdx - 1].x;
			let yDir = tempCtPts[moveIdx - 2].y - tempCtPts[moveIdx - 1].y;
			let orglen = Math.sqrt(xDir*xDir + yDir*yDir);
			xDir = tempCtPts[moveIdx - 1].x - tempCtPts[moveIdx].x;
			yDir = tempCtPts[moveIdx - 1].y - tempCtPts[moveIdx].y;
			let len = Math.sqrt(xDir*xDir + yDir*yDir);
			tempCtPts[moveIdx - 2].x = tempCtPts[moveIdx - 1].x + orglen * xDir / len;
			tempCtPts[moveIdx - 2].y = tempCtPts[moveIdx - 1].y + orglen * yDir / len;
		}
		if (isNeedUpdateNextPoint)
		{
			// next point is smooth, update next^2 point
			console.log('update: ' + (moveIdx + 2));
			let xDir = tempCtPts[moveIdx + 2].x - tempCtPts[moveIdx + 1].x;
			let yDir = tempCtPts[moveIdx + 2].y - tempCtPts[moveIdx + 1].y;
			let orglen = Math.sqrt(xDir*xDir + yDir*yDir);
			xDir = tempCtPts[moveIdx + 1].x - tempCtPts[moveIdx].x;
			yDir = tempCtPts[moveIdx + 1].y - tempCtPts[moveIdx].y;
			let len = Math.sqrt(xDir*xDir + yDir*yDir);
			tempCtPts[moveIdx + 2].x = tempCtPts[moveIdx + 1].x + orglen * xDir / len;
			tempCtPts[moveIdx + 2].y = tempCtPts[moveIdx + 1].y + orglen * yDir / len;
		}

	// 	// update bezier curve
	// 	let bcurveStr = calculateBCurve(tempCtPts);
	// 	$('#bcurve').attr('points', bcurveStr);
 
	// 	// update all control lines
	// 	for (n=0; n<tempCtPts.length-1; ++n)
	// 	{
	// 		let idStr = `#ctrl-line-${n}-${n+1}`;
	// 		$(idStr).attr('x1', tempCtPts[n].x);
	// 		$(idStr).attr('y1', tempCtPts[n].y);
	// 		$(idStr).attr('x2', tempCtPts[n+1].x);
	// 		$(idStr).attr('y2', tempCtPts[n+1].y);
	// 	}

	// 	// update all control poiints
	// 	for (n=0; n<tempCtPts.length-1; ++n)
	// 	{
	// 		let idStr = `#ctrl-point-${n}`;
	// 		$(idStr).attr('cx', tempCtPts[n].x);
	// 		$(idStr).attr('cy', tempCtPts[n].y);
	// 	}
	// }
	// else
	// {
	// 	// 目前是單純畫圖
	// 	// bezier curve
	// 	let bcurveStr = calculateBCurve(tempCtPts);
	// 	$('#bcurve').attr('points', bcurveStr);

	// 	// control-line
	// 	for (let n=0; n<ctrlPoints.length-1; ++n)
	// 	{
	// 		let idStr = `#ctrl-line-${n}-${n+1}`;
	// 		$(idStr).attr('x1', tempCtPts[n].x);
	// 		$(idStr).attr('y1', tempCtPts[n].y);
	// 		$(idStr).attr('x2', tempCtPts[n+1].x);
	// 		$(idStr).attr('y2', tempCtPts[n+1].y);
	// 	}

	// 	// control poiint
	// 	for (let n=0; n<ctrlPoints.length; ++n)
	// 	{
	// 		let idStr = `#ctrl-point-${n}`;
	// 		$(idStr).attr('cx', tempCtPts[n].x);
	// 		$(idStr).attr('cy', tempCtPts[n].y);
	// 	}
	}

	// update bezier curve
	let bcurveStr = calculateBCurve(tempCtPts);
	$('#bcurve').attr('points', bcurveStr);

	// update all control lines
	for (n=0; n<tempCtPts.length-1; ++n)
	{
		let idStr = `#ctrl-line-${n}-${n+1}`;
		$(idStr).attr('x1', tempCtPts[n].x);
		$(idStr).attr('y1', tempCtPts[n].y);
		$(idStr).attr('x2', tempCtPts[n+1].x);
		$(idStr).attr('y2', tempCtPts[n+1].y);
	}

	// update all control poiints
	for (n=0; n<tempCtPts.length; ++n)
	{
		let idStr = `#ctrl-point-${n}`;
		$(idStr).attr('cx', tempCtPts[n].x);
		$(idStr).attr('cy', tempCtPts[n].y);
	}

	if (isUpdateBack)
	{
		for (let n=0; n<tempCtPts.length; ++n) ctrlPoints[n] = {x:tempCtPts[n].x, y: tempCtPts[n].y};
	}
}

// cps: control points
function calculateBCurve(cp)
{
	let bcurveStr = '';
	for (let p=0; p<cp.length-1; p+=3)
	{
		for (let n=0; n<=100; ++n)
		{
			let t1 = n / 100.0;
			let t2 = 1 - t1;

			let px = (t2**3)*cp[p].x + 3*t1*(t2**2)*cp[p+1].x + 3*(t1**2)*t2*cp[p+2].x + (t1**3)*cp[p+3].x;
			let py = (t2**3)*cp[p].y + 3*t1*(t2**2)*cp[p+1].y + 3*(t1**2)*t2*cp[p+2].y + (t1**3)*cp[p+3].y;
			bcurveStr += `${px},${py} `;
		}
	}
	return bcurveStr.trim();
}

function createSvgObjects()
{
	let cpCount = ctrlPoints.length;

	if (cpCount == 0)
	{
		// init 4 points
		ctrlPoints.push(new Point2(100, 200));
		ctrlPoints.push(new Point2(250, 100));
		ctrlPoints.push(new Point2(250, 300));
		ctrlPoints.push(new Point2(400, 200));
		$('#bcurve-group').append(makeSVG('polyline', {id: 'bcurve', class: 'bezier-curve'}));
		$('#ctrl-line-group').append(makeSVG('line',   { id: 'ctrl-line-0-1', class: 'ctrl-line' }));
		$('#ctrl-line-group').append(makeSVG('line',   { id: 'ctrl-line-1-2', class: 'ctrl-line' }));
		$('#ctrl-line-group').append(makeSVG('line',   { id: 'ctrl-line-2-3', class: 'ctrl-line' }));
		$('#ctrl-point-group').append(makeSVG('circle', { id: 'ctrl-point-0', class: 'ctrl-point cp-end' }));
		$('#ctrl-point-group').append(makeSVG('circle', { id: 'ctrl-point-1', class: 'ctrl-point cp-mid' }));
		$('#ctrl-point-group').append(makeSVG('circle', { id: 'ctrl-point-2', class: 'ctrl-point cp-mid' }));
		$('#ctrl-point-group').append(makeSVG('circle', { id: 'ctrl-point-3', class: 'ctrl-point cp-end' }));
	}else{
		// append 3 points
		let xDir = ctrlPoints[cpCount - 1].x - ctrlPoints[cpCount - 2].x;
		let yDir = ctrlPoints[cpCount - 1].y - ctrlPoints[cpCount - 2].y;
		let len = Math.sqrt(xDir*xDir + yDir*yDir) / 100;
		let x = ctrlPoints[cpCount - 1].x;
		let y = ctrlPoints[cpCount - 1].y;
		ctrlPoints.push(new Point2(x + xDir/len, y + yDir/len));
		ctrlPoints.push(new Point2(x + xDir/len + 100, y + yDir/len));
		ctrlPoints.push(new Point2(x + xDir/len + 200, y + yDir/len));
		$('#ctrl-line-group').append(makeSVG('line',   { id: `ctrl-line-${cpCount-1}-${cpCount}`, class: 'ctrl-line' }));
		$('#ctrl-line-group').append(makeSVG('line',   { id: `ctrl-line-${cpCount}-${cpCount+1}`, class: 'ctrl-line' }));
		$('#ctrl-line-group').append(makeSVG('line',   { id: `ctrl-line-${cpCount+1}-${cpCount+2}`, class: 'ctrl-line' }));
		$('#ctrl-point-group').append(makeSVG('circle', { id: `ctrl-point-${cpCount}`, class: 'ctrl-point cp-mid' }));
		$('#ctrl-point-group').append(makeSVG('circle', { id: `ctrl-point-${cpCount+1}`, class: 'ctrl-point cp-mid' }));
		$('#ctrl-point-group').append(makeSVG('circle', { id: `ctrl-point-${cpCount+2}`, class: 'ctrl-point cp-end' }));
	}
}

function makeSVG(tag, attrs) {
	var el = document.createElementNS('http://www.w3.org/2000/svg', tag);
	for (var k in attrs) el.setAttribute(k, attrs[k]);
	return el;
}
